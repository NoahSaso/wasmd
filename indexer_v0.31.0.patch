diff --git a/app/app.go b/app/app.go
index 55d8f7cc..43b25ba2 100644
--- a/app/app.go
+++ b/app/app.go
@@ -387,6 +387,7 @@ func NewWasmApp(
 		app.AccountKeeper,
 		app.BankKeeper,
 		app.getSubspace(stakingtypes.ModuleName),
+		homePath,
 	)
 	app.MintKeeper = mintkeeper.NewKeeper(
 		appCodec,
diff --git a/go.mod b/go.mod
index 2d43bd2a..1975d5ca 100644
--- a/go.mod
+++ b/go.mod
@@ -161,3 +161,6 @@ replace (
 
 	google.golang.org/grpc => google.golang.org/grpc v1.33.2
 )
+
+// INDEXER
+replace github.com/cosmos/cosmos-sdk => github.com/NoahSaso/cosmos-sdk v0.45.14-indexer.4
diff --git a/go.sum b/go.sum
index e7f3303f..a1cd4f7f 100644
--- a/go.sum
+++ b/go.sum
@@ -82,6 +82,8 @@ github.com/Joker/hpp v1.0.0/go.mod h1:8x5n+M1Hp5hC0g8okX3sR3vFQwynaX/UgSOM9MeBKz
 github.com/Joker/jade v1.0.1-0.20190614124447-d475f43051e7/go.mod h1:6E6s8o2AE4KhCrqr6GRJjdC/gNfTdxkIXvuGZZda2VM=
 github.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0=
 github.com/Microsoft/go-winio v0.6.0 h1:slsWYD/zyx7lCXoZVlvQrj0hPTM1HI4+v1sIda2yDvg=
+github.com/NoahSaso/cosmos-sdk v0.45.14-indexer.4 h1:0mDIViiZHGkT/x2cUri2ytXHdFfi8Vm9Jouqy6pw23Y=
+github.com/NoahSaso/cosmos-sdk v0.45.14-indexer.4/go.mod h1:bF1fyVbRDvZ922GMByg9opQT26sQwabwYqaYIchwdyw=
 github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 h1:TngWCqHvy9oXAN6lEVMRuU21PR1EtLVZJmdB18Gu3Rw=
 github.com/OneOfOne/xxhash v1.2.2 h1:KMrpdQIwFcEqXDklaen+P1axHaj9BSKzvpUUfnHldSE=
 github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
@@ -206,8 +208,6 @@ github.com/cosmos/cosmos-db v0.0.0-20221226095112-f3c38ecb5e32 h1:zlCp9n3uwQieEL
 github.com/cosmos/cosmos-db v0.0.0-20221226095112-f3c38ecb5e32/go.mod h1:kwMlEC4wWvB48zAShGKVqboJL6w4zCLesaNQ3YLU2BQ=
 github.com/cosmos/cosmos-proto v1.0.0-beta.2 h1:X3OKvWgK9Gsejo0F1qs5l8Qn6xJV/AzgIWR2wZ8Nua8=
 github.com/cosmos/cosmos-proto v1.0.0-beta.2/go.mod h1:+XRCLJ14pr5HFEHIUcn51IKXD1Fy3rkEQqt4WqmN4V0=
-github.com/cosmos/cosmos-sdk v0.45.14 h1:l6yid1Lft5dd8ymKO36qJf1phsE0shJLNkZQYTwjxOg=
-github.com/cosmos/cosmos-sdk v0.45.14/go.mod h1:bF1fyVbRDvZ922GMByg9opQT26sQwabwYqaYIchwdyw=
 github.com/cosmos/go-bip39 v0.0.0-20180819234021-555e2067c45d/go.mod h1:tSxLoYXyBmiFeKpvmq4dzayMdCjCnu8uqmCysIGBT2Y=
 github.com/cosmos/go-bip39 v1.0.0 h1:pcomnQdrdH22njcAatO0yWojsUnCO3y2tNoV1cb6hHY=
 github.com/cosmos/go-bip39 v1.0.0/go.mod h1:RNJv0H/pOIVgxw6KS7QeX2a0Uo0aKUlfhZ4xuwvCdJw=
diff --git a/x/wasm/keeper/keeper.go b/x/wasm/keeper/keeper.go
index 16a248e5..861ff899 100644
--- a/x/wasm/keeper/keeper.go
+++ b/x/wasm/keeper/keeper.go
@@ -15,6 +15,7 @@ import (
 	wasmvm "github.com/CosmWasm/wasmvm"
 	wasmvmtypes "github.com/CosmWasm/wasmvm/types"
 	"github.com/cosmos/cosmos-sdk/codec"
+	"github.com/cosmos/cosmos-sdk/store/listenkv"
 	"github.com/cosmos/cosmos-sdk/store/prefix"
 	"github.com/cosmos/cosmos-sdk/telemetry"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -26,6 +27,8 @@ import (
 
 	"github.com/CosmWasm/wasmd/x/wasm/ioutils"
 	"github.com/CosmWasm/wasmd/x/wasm/types"
+
+	sdkstore "github.com/cosmos/cosmos-sdk/store/types"
 )
 
 // contractMemoryLimit is the memory limit of each contract execution (in MiB)
@@ -82,6 +85,13 @@ var defaultAcceptedAccountTypes = map[reflect.Type]struct{}{
 	reflect.TypeOf(&authtypes.BaseAccount{}): {},
 }
 
+// INDEXER.
+var CurrentIndexerStateListener *IndexerStateWriteListener
+var CurrentIndexerTxWriter *IndexerTxWriter
+var CurrentIndexerTxBlockHeight int64
+var CurrentIndexerTxIndex uint32
+var CurrentIndexerTxRootMessageIndex uint32
+
 // Keeper will have a reference to Wasmer with it's own data directory.
 type Keeper struct {
 	storeKey              sdk.StoreKey
@@ -101,6 +111,69 @@ type Keeper struct {
 	maxQueryStackSize    uint32
 	acceptedAccountTypes map[reflect.Type]struct{}
 	accountPruner        AccountPruner
+
+	// INDEXER.
+	indexerConfig IndexerConfig
+}
+
+// INDEXER: Setup indexer listener and writer.
+func (k Keeper) setupIndexer(ctx *sdk.Context, env *wasmvmtypes.Env, prefixStore *prefix.Store, contractAddress sdk.AccAddress, codeID uint64) (wasmvmtypes.KVStore, *IndexerStateWriteListener, *IndexerTxWriter) {
+	// If checking TX (simulating, not actually executing), do not attach indexer.
+	// Return prefixStore not wrapped with listenkv.
+	if ctx.IsCheckTx() {
+		return types.NewStoreAdapter(prefixStore), nil, nil
+	}
+
+	// Create state listener.
+	stateListener := NewIndexerStateWriteListener(
+		k.indexerConfig,
+		CurrentIndexerStateListener,
+		ctx,
+		// Contract info.
+		contractAddress,
+		codeID,
+	)
+
+	// If we fail to create a new listener, return prefixStore not wrapped with
+	// listenkv. This may happen if a config filter is not met.
+	if stateListener == nil {
+		return types.NewStoreAdapter(prefixStore), nil, nil
+	}
+
+	// Update CurrentIndexerListener.
+	CurrentIndexerStateListener = stateListener
+
+	// Create KV listenStore that calls the listener when data is updated. Store
+	// key does not matter.
+	listenStore := listenkv.NewStore(prefixStore, k.storeKey, []sdkstore.WriteListener{
+		stateListener,
+	})
+
+	// If on a new block height or transaction index, reset the root-level message
+	// index. The appropriate message index (the root-level or a parent's
+	// sub-message index) will be incremented automatically by the TX writer when
+	// it finishes.
+	if CurrentIndexerTxBlockHeight != ctx.BlockHeight() || env.Transaction.Index != CurrentIndexerTxIndex {
+		CurrentIndexerTxWriter = nil
+		CurrentIndexerTxRootMessageIndex = 0
+	}
+
+	// Update the current values of the block height and transaction index.
+	CurrentIndexerTxBlockHeight = ctx.BlockHeight()
+	CurrentIndexerTxIndex = env.Transaction.Index
+
+	// Create TX writer.
+	txWriter := NewIndexerTxWriter(
+		k.indexerConfig,
+		CurrentIndexerTxWriter,
+		ctx,
+		env,
+	)
+
+	// Update CurrentIndexerTxWriter.
+	CurrentIndexerTxWriter = txWriter
+
+	return types.NewStoreAdapter(listenStore), stateListener, txWriter
 }
 
 func (k Keeper) getUploadAccessConfig(ctx sdk.Context) types.AccessConfig {
@@ -289,14 +362,23 @@ func (k Keeper) instantiate(
 	// create prefixed data store
 	// 0x03 | BuildContractAddressClassic (sdk.AccAddress)
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
-	vmStore := types.NewStoreAdapter(prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey))
+	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
+
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, codeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
 
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 
 	// instantiate wasm contract
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, vmStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, nil, sdkerrors.Wrap(types.ErrInstantiateFailed, err.Error())
@@ -333,11 +415,21 @@ func (k Keeper) instantiate(
 		sdk.NewAttribute(types.AttributeKeyCodeID, strconv.FormatUint(codeID, 10)),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	if txWriter != nil {
+		txWriter.write(contractAddress, codeID, "instantiate", creator.String(), &initMsg, nil, deposit, res, gasUsed)
+	}
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return contractAddress, data, nil
 }
 
@@ -362,10 +454,19 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 	env := types.NewEnv(ctx, contractAddress)
 	info := types.NewInfo(caller, coins)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -376,11 +477,21 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	if txWriter != nil {
+		txWriter.write(contractAddress, contractInfo.CodeID, "execute", caller.String(), &msg, nil, coins, res, gasUsed)
+	}
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -428,9 +539,19 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 	querier := k.newQueryHandler(ctx, contractAddress)
 
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
-	vmStore := types.NewStoreAdapter(prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey))
+	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
+
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, newCodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, vmStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, indexerStateStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, sdkerrors.Wrap(types.ErrMigrationFailed, err.Error())
@@ -449,11 +570,21 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	if txWriter != nil {
+		txWriter.write(contractAddress, newCodeID, "migrate", caller.String(), &msg, nil, sdk.NewCoins(), res, gasUsed)
+	}
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -472,10 +603,19 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -486,11 +626,21 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	if txWriter != nil {
+		txWriter.write(contractAddress, contractInfo.CodeID, "sudo", "sudo", &msg, nil, sdk.NewCoins(), res, gasUsed)
+	}
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -507,11 +657,20 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
 
-	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -522,11 +681,21 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	if txWriter != nil {
+		txWriter.write(contractAddress, contractInfo.CodeID, "reply", "reply", nil, &reply, sdk.NewCoins(), res, gasUsed)
+	}
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -662,7 +831,7 @@ func (k Keeper) QuerySmart(ctx sdk.Context, contractAddr sdk.AccAddress, req []b
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	env := types.NewEnv(ctx, contractAddr)
-	queryResult, gasUsed, qErr := k.wasmVM.Query(codeInfo.CodeHash, env, req, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), k.runtimeGasForContract(ctx), costJSONDeserialization)
+	queryResult, gasUsed, qErr := k.wasmVM.Query(codeInfo.CodeHash, env, req, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, k.gasMeter(ctx), k.runtimeGasForContract(ctx), costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if qErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrQueryFailed, qErr.Error())
@@ -706,7 +875,7 @@ func (k Keeper) QueryRaw(ctx sdk.Context, contractAddress sdk.AccAddress, key []
 }
 
 // internal helper function
-func (k Keeper) contractInstance(ctx sdk.Context, contractAddress sdk.AccAddress) (types.ContractInfo, types.CodeInfo, wasmvm.KVStore, error) {
+func (k Keeper) contractInstance(ctx sdk.Context, contractAddress sdk.AccAddress) (types.ContractInfo, types.CodeInfo, *prefix.Store, error) {
 	store := ctx.KVStore(k.storeKey)
 
 	contractBz := store.Get(types.GetContractAddressKey(contractAddress))
@@ -724,7 +893,7 @@ func (k Keeper) contractInstance(ctx sdk.Context, contractAddress sdk.AccAddress
 	k.cdc.MustUnmarshal(codeInfoBz, &codeInfo)
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
 	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
-	return contractInfo, codeInfo, types.NewStoreAdapter(prefixStore), nil
+	return contractInfo, codeInfo, &prefixStore, nil
 }
 
 func (k Keeper) GetContractInfo(ctx sdk.Context, contractAddress sdk.AccAddress) *types.ContractInfo {
diff --git a/x/wasm/keeper/keeper_cgo.go b/x/wasm/keeper/keeper_cgo.go
index 06a0ccab..f817db37 100644
--- a/x/wasm/keeper/keeper_cgo.go
+++ b/x/wasm/keeper/keeper_cgo.go
@@ -43,6 +43,8 @@ func NewKeeper(
 		paramSpace = paramSpace.WithKeyTable(types.ParamKeyTable())
 	}
 
+	indexerConfig := LoadIndexerConfig(filepath.Join(homeDir, ".."))
+
 	keeper := &Keeper{
 		storeKey:             storeKey,
 		cdc:                  cdc,
@@ -58,6 +60,7 @@ func NewKeeper(
 		gasRegister:          NewDefaultWasmGasRegister(),
 		maxQueryStackSize:    types.DefaultMaxQueryStackSize,
 		acceptedAccountTypes: defaultAcceptedAccountTypes,
+		indexerConfig:        indexerConfig,
 	}
 	keeper.wasmVMQueryHandler = DefaultQueryPlugins(bankKeeper, stakingKeeper, distKeeper, channelKeeper, keeper)
 	for _, o := range opts {
diff --git a/x/wasm/keeper/relay.go b/x/wasm/keeper/relay.go
index 7c3f0b90..7eb0aab6 100644
--- a/x/wasm/keeper/relay.go
+++ b/x/wasm/keeper/relay.go
@@ -33,7 +33,7 @@ func (k Keeper) OnOpenChannel(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCChannelOpen(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCChannelOpen(codeInfo.CodeHash, env, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return "", sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -66,7 +66,7 @@ func (k Keeper) OnConnectChannel(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCChannelConnect(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCChannelConnect(codeInfo.CodeHash, env, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -97,7 +97,7 @@ func (k Keeper) OnCloseChannel(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCChannelClose(codeInfo.CodeHash, params, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCChannelClose(codeInfo.CodeHash, params, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -127,7 +127,7 @@ func (k Keeper) OnRecvPacket(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCPacketReceive(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCPacketReceive(codeInfo.CodeHash, env, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -161,7 +161,7 @@ func (k Keeper) OnAckPacket(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCPacketAck(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCPacketAck(codeInfo.CodeHash, env, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -188,7 +188,7 @@ func (k Keeper) OnTimeoutPacket(
 	querier := k.newQueryHandler(ctx, contractAddr)
 
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.IBCPacketTimeout(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.IBCPacketTimeout(codeInfo.CodeHash, env, msg, types.NewStoreAdapter(prefixStore), cosmwasmAPI, querier, ctx.GasMeter(), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
diff --git a/x/wasm/keeper/test_common.go b/x/wasm/keeper/test_common.go
index b84e0025..c256ac28 100644
--- a/x/wasm/keeper/test_common.go
+++ b/x/wasm/keeper/test_common.go
@@ -304,6 +304,7 @@ func createTestInput(
 		accountKeeper,
 		bankKeeper,
 		subspace(stakingtypes.ModuleName),
+		"",
 	)
 	stakingKeeper.SetParams(ctx, TestingStakeParams)
 
