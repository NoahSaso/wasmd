diff --git a/x/wasm/keeper/indexer.go b/x/wasm/keeper/indexer.go
new file mode 100644
index 00000000..f1b65bd6
--- /dev/null
+++ b/x/wasm/keeper/indexer.go
@@ -0,0 +1,182 @@
+package keeper
+
+import (
+	"encoding/base64"
+	"encoding/json"
+	"os"
+	"path/filepath"
+
+	sdkstoretypes "github.com/cosmos/cosmos-sdk/store/types"
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+	"github.com/tendermint/tendermint/libs/log"
+)
+
+type IndexerConfigFilter struct {
+	CodeIds           []uint64 `json:"codeIds"`
+	ContractAddresses []string `json:"contractAddresses"`
+}
+
+type IndexerConfig struct {
+	Filter IndexerConfigFilter `json:"filter"`
+	// Set manually.
+	Output string
+}
+
+func LoadIndexerConfig(wasmdDir string) IndexerConfig {
+	var config IndexerConfig
+	configFile, err := os.Open(filepath.Join(wasmdDir, "indexer", "config.json"))
+	if err != nil {
+		panic(err.Error())
+	}
+	defer configFile.Close()
+	jsonParser := json.NewDecoder(configFile)
+	jsonParser.Decode(&config)
+
+	// Resolve output path.
+	config.Output = filepath.Join(wasmdDir, "indexer", ".events.txt")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(config.Output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	return config
+}
+
+type PendingIndexerEvent struct {
+	BlockHeight        int64  `json:"blockHeight"`
+	BlockTimeUnixMicro int64  `json:"blockTimeUnixMicro"`
+	ContractAddress    string `json:"contractAddress"`
+	CodeId             uint64 `json:"codeId"`
+	Key                string `json:"key"`
+	Value              string `json:"value"`
+	Delete             bool   `json:"delete"`
+}
+
+type IndexerWriteListener struct {
+	parentIndexerListener *IndexerWriteListener
+	logger                log.Logger
+	output                string
+
+	queue     map[string]PendingIndexerEvent
+	committed bool
+
+	// Contract info.
+	contractAddress    string
+	codeID             uint64
+	blockHeight        int64
+	blockTimeUnixMicro int64
+}
+
+func NewIndexerWriteListener(config IndexerConfig, parentIndexerListener *IndexerWriteListener, ctx *sdktypes.Context, contractAddress sdktypes.AccAddress, codeID uint64) *IndexerWriteListener {
+	// If there are any filters set, check them.
+	if len(config.Filter.CodeIds) != 0 || len(config.Filter.ContractAddresses) != 0 {
+		found := false
+
+		if len(config.Filter.CodeIds) != 0 {
+			for _, c := range config.Filter.CodeIds {
+				if c == codeID {
+					found = true
+					break
+				}
+			}
+		}
+
+		// Only check contract addresses if we have not yet found a match.
+		if !found && len(config.Filter.ContractAddresses) != 0 {
+			for _, c := range config.Filter.ContractAddresses {
+				if c == contractAddress.String() {
+					found = true
+					break
+				}
+			}
+		}
+
+		// If filter is set and we didn't find a match, don't create a listener.
+		if !found {
+			return nil
+		}
+	}
+
+	return &IndexerWriteListener{
+		parentIndexerListener: parentIndexerListener,
+		logger:                ctx.Logger(),
+		output:                config.Output,
+
+		queue:     make(map[string]PendingIndexerEvent),
+		committed: false,
+
+		// Contract info.
+		contractAddress:    contractAddress.String(),
+		codeID:             codeID,
+		blockHeight:        ctx.BlockHeight(),
+		blockTimeUnixMicro: ctx.BlockTime().UnixMicro(),
+	}
+}
+
+// Add write events to queue.
+func (wl *IndexerWriteListener) OnWrite(storeKey sdkstoretypes.StoreKey, key []byte, value []byte, delete bool) error {
+	keyBase64 := base64.StdEncoding.EncodeToString(key)
+	valueBase64 := base64.StdEncoding.EncodeToString(value)
+
+	// Values are unique to the pair of contract address and key. The last value
+	// write (set or delete) in a block wins. This listener/queue only exists in
+	// the context of a single block, so we don't need to include block height in
+	// this unique key.
+	queueKey := wl.contractAddress + keyBase64
+
+	wl.queue[queueKey] = PendingIndexerEvent{
+		BlockHeight:        wl.blockHeight,
+		BlockTimeUnixMicro: wl.blockTimeUnixMicro,
+		ContractAddress:    wl.contractAddress,
+		CodeId:             wl.codeID,
+		Key:                keyBase64,
+		Value:              valueBase64,
+		Delete:             delete,
+	}
+
+	return nil
+}
+
+// Commit entire queue. This should be called if the transaction succeeds.
+func (wl *IndexerWriteListener) commit() {
+	// Add all events to parent listener queue if exists.
+	if wl.parentIndexerListener != nil {
+		for k, v := range wl.queue {
+			wl.parentIndexerListener.queue[k] = v
+		}
+	}
+	wl.committed = true
+}
+
+// If we failed to commit or are not the parent listener, don't export the
+// queue. If we are not the root listener, we added our events to our parent's
+// queue when we committed. Our child listeners added their events to our queue
+// if they committed. The root (parent with no parent) listener will export the
+// whole queue (below) if it commits.
+func (wl *IndexerWriteListener) finish() {
+	// Move the current indexer listener pointer up one to our parent. If we are
+	// the root listener, this will be nil.
+	CurrentIndexerListener = wl.parentIndexerListener
+
+	if !wl.committed || wl.parentIndexerListener != nil {
+		return
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(wl.output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		wl.logger.Error("[INDEXER] Failed to open output file", "output", wl.output, "error", err)
+		panic(err.Error())
+	}
+	defer file.Close()
+
+	encoder := json.NewEncoder(file)
+
+	// Export entire queue.
+	for _, event := range wl.queue {
+		encoder.Encode(event)
+	}
+
+	wl.logger.Info("[INDEXER] Exported events", "blockHeight", wl.blockHeight, "codeId", wl.codeID, "contractAddress", wl.contractAddress, "count", len(wl.queue), "output", wl.output)
+}
diff --git a/x/wasm/keeper/keeper.go b/x/wasm/keeper/keeper.go
index b56faa16..8468dd37 100644
--- a/x/wasm/keeper/keeper.go
+++ b/x/wasm/keeper/keeper.go
@@ -15,6 +15,7 @@ import (
 	wasmvm "github.com/CosmWasm/wasmvm"
 	wasmvmtypes "github.com/CosmWasm/wasmvm/types"
 	"github.com/cosmos/cosmos-sdk/codec"
+	"github.com/cosmos/cosmos-sdk/store/listenkv"
 	"github.com/cosmos/cosmos-sdk/store/prefix"
 	"github.com/cosmos/cosmos-sdk/telemetry"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -23,6 +24,8 @@ import (
 	"github.com/tendermint/tendermint/libs/log"
 
 	"github.com/CosmWasm/wasmd/x/wasm/types"
+
+	sdkstore "github.com/cosmos/cosmos-sdk/store/types"
 )
 
 // contractMemoryLimit is the memory limit of each contract execution (in MiB)
@@ -57,6 +60,9 @@ type WasmVMResponseHandler interface {
 	) ([]byte, error)
 }
 
+// INDEXER.
+var CurrentIndexerListener *IndexerWriteListener
+
 // Keeper will have a reference to Wasmer with it's own data directory.
 type Keeper struct {
 	storeKey              sdk.StoreKey
@@ -73,6 +79,9 @@ type Keeper struct {
 	queryGasLimit uint64
 	paramSpace    paramtypes.Subspace
 	gasRegister   GasRegister
+
+	// INDEXER.
+	indexerConfig IndexerConfig
 }
 
 // NewKeeper creates a new contract Keeper instance
@@ -117,6 +126,7 @@ func NewKeeper(
 		queryGasLimit:    wasmConfig.SmartQueryGasLimit,
 		paramSpace:       paramSpace,
 		gasRegister:      NewDefaultWasmGasRegister(),
+		indexerConfig:    LoadIndexerConfig(filepath.Join(homeDir, "..")),
 	}
 	keeper.wasmVMQueryHandler = DefaultQueryPlugins(bankKeeper, stakingKeeper, distKeeper, channelKeeper, queryRouter, keeper)
 	for _, o := range opts {
@@ -127,6 +137,39 @@ func NewKeeper(
 	return *keeper
 }
 
+// INDEXER: Listen to KV Store changes.
+func (k Keeper) attachIndexer(prefixStore *prefix.Store, ctx *sdk.Context, contractAddress sdk.AccAddress, codeID uint64) (sdkstore.KVStore, *IndexerWriteListener) {
+	// If checking TX (simulating, not actually executing), do not attach indexer.
+	// Return prefixStore not wrapped with listenkv.
+	if ctx.IsCheckTx() {
+		return prefixStore, nil
+	}
+
+	// Create new listener.
+	listener := NewIndexerWriteListener(
+		k.indexerConfig,
+		CurrentIndexerListener,
+		ctx,
+		// Contract info.
+		contractAddress,
+		codeID,
+	)
+
+	// If we fail to create a new listener, return prefixStore not wrapped with
+	// listenkv. This may happen if a config filter is not met.
+	if listener == nil {
+		return prefixStore, nil
+	}
+
+	// Update CurrentIndexerListener.
+	CurrentIndexerListener = listener
+
+	// (Store key does not matter.)
+	return listenkv.NewStore(prefixStore, k.storeKey, []sdkstore.WriteListener{
+		listener,
+	}), listener
+}
+
 func (k Keeper) getUploadAccessConfig(ctx sdk.Context) types.AccessConfig {
 	var a types.AccessConfig
 	k.paramSpace.Get(ctx, types.ParamStoreKeyUploadAccess, &a)
@@ -276,12 +319,18 @@ func (k Keeper) instantiate(ctx sdk.Context, codeID uint64, creator, admin sdk.A
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
 	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
 
+	// INDEXER: Listen to KV Store changes.
+	indexerStore, listener := k.attachIndexer(&prefixStore, &ctx, contractAddress, codeID)
+	if listener != nil {
+		defer listener.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 
 	// instantiate wasm contract
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, indexerStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, nil, sdkerrors.Wrap(types.ErrInstantiateFailed, err.Error())
@@ -322,6 +371,11 @@ func (k Keeper) instantiate(ctx sdk.Context, codeID uint64, creator, admin sdk.A
 		return nil, nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	if listener != nil {
+		// INDEXER: On success, commit.
+		listener.commit()
+	}
+
 	return contractAddress, data, nil
 }
 
@@ -346,10 +400,16 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 	env := types.NewEnv(ctx, contractAddress)
 	info := types.NewInfo(caller, coins)
 
+	// INDEXER: Listen to KV Store changes.
+	indexerStore, listener := k.attachIndexer(&prefixStore, &ctx, contractAddress, contractInfo.CodeID)
+	if listener != nil {
+		defer listener.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, indexerStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -365,6 +425,11 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	if listener != nil {
+		// INDEXER: On success, commit.
+		listener.commit()
+	}
+
 	return data, nil
 }
 
@@ -409,8 +474,15 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
 	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
+
+	// INDEXER: Listen to KV Store changes.
+	indexerStore, listener := k.attachIndexer(&prefixStore, &ctx, contractAddress, contractInfo.CodeID)
+	if listener != nil {
+		defer listener.finish()
+	}
+
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, &prefixStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, indexerStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, sdkerrors.Wrap(types.ErrMigrationFailed, err.Error())
@@ -435,6 +507,11 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	if listener != nil {
+		// INDEXER: On success, commit.
+		listener.commit()
+	}
+
 	return data, nil
 }
 
@@ -453,10 +530,16 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Listen to KV Store changes.
+	indexerStore, listener := k.attachIndexer(&prefixStore, &ctx, contractAddress, contractInfo.CodeID)
+	if listener != nil {
+		defer listener.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, indexerStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -472,6 +555,11 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	if listener != nil {
+		// INDEXER: On success, commit.
+		listener.commit()
+	}
+
 	return data, nil
 }
 
@@ -488,10 +576,16 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Listen to KV Store changes.
+	indexerStore, listener := k.attachIndexer(&prefixStore, &ctx, contractAddress, contractInfo.CodeID)
+	if listener != nil {
+		defer listener.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, indexerStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -507,6 +601,11 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	if listener != nil {
+		// INDEXER: On success, commit.
+		listener.commit()
+	}
+
 	return data, nil
 }
 
