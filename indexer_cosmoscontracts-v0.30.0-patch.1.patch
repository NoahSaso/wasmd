diff --git a/app/app.go b/app/app.go
index 569f22e..5676702 100644
--- a/app/app.go
+++ b/app/app.go
@@ -387,6 +387,7 @@ func NewWasmApp(
 		app.AccountKeeper,
 		app.BankKeeper,
 		app.getSubspace(stakingtypes.ModuleName),
+		homePath,
 	)
 	app.MintKeeper = mintkeeper.NewKeeper(
 		appCodec,
diff --git a/go.mod b/go.mod
index 9140e8e..183d167 100644
--- a/go.mod
+++ b/go.mod
@@ -139,3 +139,6 @@ replace (
 	github.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1
 	google.golang.org/grpc => google.golang.org/grpc v1.33.2
 )
+
+// INDEXER
+replace github.com/cosmos/cosmos-sdk => github.com/NoahSaso/cosmos-sdk v0.45.11-indexer.3
diff --git a/go.sum b/go.sum
index c7b2fad..6f8e5e9 100644
--- a/go.sum
+++ b/go.sum
@@ -66,6 +66,8 @@ github.com/DataDog/zstd v1.4.1/go.mod h1:1jcaCB/ufaK+sKp1NBhlGmpz41jOoPQ35bpF36t
 github.com/DataDog/zstd v1.4.5/go.mod h1:1jcaCB/ufaK+sKp1NBhlGmpz41jOoPQ35bpF36t7BBo=
 github.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0=
 github.com/Microsoft/go-winio v0.6.0 h1:slsWYD/zyx7lCXoZVlvQrj0hPTM1HI4+v1sIda2yDvg=
+github.com/NoahSaso/cosmos-sdk v0.45.11-indexer.3 h1:rHRFf4Sd0clIafefFn6HlOYQDkGSzwKvwJRk7bOh7rw=
+github.com/NoahSaso/cosmos-sdk v0.45.11-indexer.3/go.mod h1:45z8Q1Ah4iypFycu2Kl4kBPIsQKUiND8G2CUX+HTtPM=
 github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 h1:TngWCqHvy9oXAN6lEVMRuU21PR1EtLVZJmdB18Gu3Rw=
 github.com/OneOfOne/xxhash v1.2.2 h1:KMrpdQIwFcEqXDklaen+P1axHaj9BSKzvpUUfnHldSE=
 github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
@@ -162,8 +164,6 @@ github.com/cosmos/btcutil v1.0.4 h1:n7C2ngKXo7UC9gNyMNLbzqz7Asuf+7Qv4gnX/rOdQ44=
 github.com/cosmos/btcutil v1.0.4/go.mod h1:Ffqc8Hn6TJUdDgHBwIZLtrLQC1KdJ9jGJl/TvgUaxbU=
 github.com/cosmos/cosmos-proto v1.0.0-alpha8 h1:d3pCRuMYYvGA5bM0ZbbjKn+AoQD4A7dyNG2wzwWalUw=
 github.com/cosmos/cosmos-proto v1.0.0-alpha8/go.mod h1:6/p+Bc4O8JKeZqe0VqUGTX31eoYqemTT4C1hLCWsO7I=
-github.com/cosmos/cosmos-sdk v0.45.11 h1:Pc44fFEkai0KXFND5Ys/2ZJkfVdstMIBzKBN8MY7Ll0=
-github.com/cosmos/cosmos-sdk v0.45.11/go.mod h1:45z8Q1Ah4iypFycu2Kl4kBPIsQKUiND8G2CUX+HTtPM=
 github.com/cosmos/cosmos-sdk/ics23/go v0.8.0 h1:iKclrn3YEOwk4jQHT2ulgzuXyxmzmPczUalMwW4XH9k=
 github.com/cosmos/cosmos-sdk/ics23/go v0.8.0/go.mod h1:2a4dBq88TUoqoWAU5eu0lGvpFP3wWDPgdHPargtyw30=
 github.com/cosmos/go-bip39 v0.0.0-20180819234021-555e2067c45d/go.mod h1:tSxLoYXyBmiFeKpvmq4dzayMdCjCnu8uqmCysIGBT2Y=
diff --git a/x/wasm/keeper/indexer.go b/x/wasm/keeper/indexer.go
new file mode 100644
index 0000000..830c55a
--- /dev/null
+++ b/x/wasm/keeper/indexer.go
@@ -0,0 +1,318 @@
+package keeper
+
+import (
+	"encoding/base64"
+	"encoding/json"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	wasmvmtypes "github.com/CosmWasm/wasmvm/types"
+	sdkstoretypes "github.com/cosmos/cosmos-sdk/store/types"
+	sdktypes "github.com/cosmos/cosmos-sdk/types"
+)
+
+type IndexerConfigFilter struct {
+	CodeIds           []uint64 `json:"codeIds"`
+	ContractAddresses []string `json:"contractAddresses"`
+}
+
+type IndexerConfig struct {
+	Filter IndexerConfigFilter `json:"filter"`
+	// Set manually.
+	Output string
+}
+
+func LoadIndexerConfig(wasmdDir string) IndexerConfig {
+	var config IndexerConfig
+	configFile, err := os.Open(filepath.Join(wasmdDir, "indexer", "config.json"))
+	// Read config from file if it exists. Otherwise, use default config.
+	if err == nil {
+		defer configFile.Close()
+		jsonParser := json.NewDecoder(configFile)
+		jsonParser.Decode(&config)
+	}
+
+	// Resolve output path.
+	config.Output = filepath.Join(wasmdDir, "indexer", "wasm.out")
+	// Create folder if doesn't exist.
+	dir := filepath.Dir(config.Output)
+	if _, err := os.Stat(dir); os.IsNotExist(err) {
+		os.MkdirAll(dir, os.ModePerm)
+	}
+
+	return config
+}
+
+// State
+
+type PendingIndexerStateEvent struct {
+	Type            string `json:"type"`
+	BlockHeight     int64  `json:"blockHeight"`
+	BlockTimeUnixMs int64  `json:"blockTimeUnixMs"`
+	ContractAddress string `json:"contractAddress"`
+	CodeId          uint64 `json:"codeId"`
+	Key             string `json:"key"`
+	Value           string `json:"value"`
+	Delete          bool   `json:"delete"`
+}
+
+type IndexerStateWriteListener struct {
+	parentListener *IndexerStateWriteListener
+	ctx            *sdktypes.Context
+	output         string
+
+	queue     map[string]PendingIndexerStateEvent
+	committed bool
+
+	// Contract info.
+	contractAddress string
+	codeID          uint64
+}
+
+func NewIndexerStateWriteListener(config IndexerConfig, parentListener *IndexerStateWriteListener, ctx *sdktypes.Context, contractAddress sdktypes.AccAddress, codeID uint64) *IndexerStateWriteListener {
+	// If there are any filters set, check them.
+	if len(config.Filter.CodeIds) != 0 || len(config.Filter.ContractAddresses) != 0 {
+		found := false
+
+		if len(config.Filter.CodeIds) != 0 {
+			for _, c := range config.Filter.CodeIds {
+				if c == codeID {
+					found = true
+					break
+				}
+			}
+		}
+
+		// Only check contract addresses if we have not yet found a match.
+		if !found && len(config.Filter.ContractAddresses) != 0 {
+			for _, c := range config.Filter.ContractAddresses {
+				if c == contractAddress.String() {
+					found = true
+					break
+				}
+			}
+		}
+
+		// If filter is set and we didn't find a match, don't create a listener.
+		if !found {
+			return nil
+		}
+	}
+
+	return &IndexerStateWriteListener{
+		parentListener: parentListener,
+		ctx:            ctx,
+		output:         config.Output,
+
+		queue:     make(map[string]PendingIndexerStateEvent),
+		committed: false,
+
+		// Contract info.
+		contractAddress: contractAddress.String(),
+		codeID:          codeID,
+	}
+}
+
+// Add write events to queue.
+func (wl *IndexerStateWriteListener) OnWrite(storeKey sdkstoretypes.StoreKey, key []byte, value []byte, delete bool) error {
+	keyBase64 := base64.StdEncoding.EncodeToString(key)
+	valueBase64 := base64.StdEncoding.EncodeToString(value)
+
+	// Values are unique to the pair of contract address and key. The last value
+	// write (set or delete) in a block wins. This listener/queue only exists in
+	// the context of a single block, so we don't need to include block height in
+	// this unique key.
+	queueKey := wl.contractAddress + keyBase64
+
+	wl.queue[queueKey] = PendingIndexerStateEvent{
+		Type:            "state",
+		BlockHeight:     wl.ctx.BlockHeight(),
+		BlockTimeUnixMs: wl.ctx.BlockTime().UnixMilli(),
+		ContractAddress: wl.contractAddress,
+		CodeId:          wl.codeID,
+		Key:             keyBase64,
+		Value:           valueBase64,
+		Delete:          delete,
+	}
+
+	return nil
+}
+
+// Commit entire queue. This should be called if the transaction succeeds.
+func (wl *IndexerStateWriteListener) commit() {
+	// Add all events to parent listener queue if exists.
+	if wl.parentListener != nil {
+		for k, v := range wl.queue {
+			wl.parentListener.queue[k] = v
+		}
+	}
+	wl.committed = true
+}
+
+// If we failed to commit or are not the parent listener, don't export the
+// queue. If we are not the root listener, we added our events to our parent's
+// queue when we committed. Our child listeners added their events to our queue
+// if they committed. The root (parent with no parent) listener will export the
+// whole queue (below) if it commits.
+func (wl *IndexerStateWriteListener) finish() {
+	// Move the current indexer listener pointer up one to our parent. If we are
+	// the root listener, this will be nil.
+	CurrentIndexerStateListener = wl.parentListener
+
+	if !wl.committed || wl.parentListener != nil {
+		return
+	}
+
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(wl.output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		wl.ctx.Logger().Error("[INDEXER][wasm/state] Failed to open output file", "output", wl.output, "error", err)
+		panic(err.Error())
+	}
+	defer file.Close()
+
+	encoder := json.NewEncoder(file)
+
+	// Export entire queue.
+	for _, event := range wl.queue {
+		encoder.Encode(event)
+	}
+
+	wl.ctx.Logger().Info("[INDEXER][wasm/state] Exported events", "blockHeight", wl.ctx.BlockHeight(), "codeId", wl.codeID, "contractAddress", wl.contractAddress, "count", len(wl.queue), "output", wl.output)
+}
+
+// TXs
+
+type IndexerTxEvent struct {
+	Type            string                `json:"type"`
+	BlockHeight     int64                 `json:"blockHeight"`
+	BlockTimeUnixMs int64                 `json:"blockTimeUnixMs"`
+	TxIndex         uint32                `json:"txIndex"`
+	MessageId       string                `json:"messageId"`
+	ContractAddress string                `json:"contractAddress"`
+	CodeId          uint64                `json:"codeId"`
+	Action          string                `json:"action"`
+	Sender          string                `json:"sender"`
+	Msg             string                `json:"msg"`
+	Reply           *wasmvmtypes.Reply    `json:"reply"`
+	Funds           sdktypes.Coins        `json:"funds"`
+	Response        *wasmvmtypes.Response `json:"response"`
+	GasUsed         uint64                `json:"gasUsed"`
+}
+
+type IndexerTxWriter struct {
+	parentWriter *IndexerTxWriter
+	output       string
+	file         *os.File
+
+	ctx *sdktypes.Context
+	env *wasmvmtypes.Env
+
+	// The message index of the current message within its lineage of messages
+	// will be appended to a string of all message indexes in the lineage
+	// traversed via the parent writer to generate a unique message ID for every
+	// message within a given transaction within a given block. The sub-message
+	// index tracks the sub-writers to give them the appropriate index. The
+	// sub-message index is incremented when each of our sub-writers finishes.
+	messageIndex    uint32
+	subMessageIndex uint32
+}
+
+func NewIndexerTxWriter(config IndexerConfig, parentWriter *IndexerTxWriter, ctx *sdktypes.Context, env *wasmvmtypes.Env) *IndexerTxWriter {
+	// Open output file, creating if doesn't exist.
+	file, err := os.OpenFile(config.Output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
+	if err != nil {
+		panic(fmt.Errorf("[INDEXER][wasm/tx] Failed to open output file. output=%v, error=%w", config.Output, err))
+	}
+
+	var messageIndex uint32
+	// If we have a parent writer, use its sub message index. Otherwise, use the
+	// root TX-level message index.
+	if parentWriter != nil {
+		messageIndex = parentWriter.subMessageIndex
+	} else {
+		messageIndex = CurrentIndexerTxRootMessageIndex
+	}
+
+	return &IndexerTxWriter{
+		parentWriter: parentWriter,
+		output:       config.Output,
+		file:         file,
+
+		ctx: ctx,
+		env: env,
+
+		messageIndex:    messageIndex,
+		subMessageIndex: 0,
+	}
+}
+
+func (iw *IndexerTxWriter) getMessageId() string {
+	currentMessageId := fmt.Sprintf("%d", iw.messageIndex)
+
+	// If we have a parent writer, append our message index to its message ID.
+	if iw.parentWriter != nil {
+		return iw.parentWriter.getMessageId() + "." + currentMessageId
+	}
+
+	// Otherwise, we are the root writer, so just use our local message ID.
+	return currentMessageId
+}
+
+func (iw *IndexerTxWriter) finish() {
+	// Move the current indexer writer pointer up to our parent. If we are the
+	// root writer, this will be nil.
+	CurrentIndexerTxWriter = iw.parentWriter
+
+	// Increment the parent indexer's sub-message index. If no parent, increment
+	// the root TX-level message index.
+	if iw.parentWriter != nil {
+		iw.parentWriter.subMessageIndex++
+	} else {
+		CurrentIndexerTxRootMessageIndex++
+	}
+
+	// Close file.
+	iw.file.Close()
+}
+
+// Write tx event to file.
+func (iw *IndexerTxWriter) write(contractAddress sdktypes.AccAddress, codeID uint64, action string, sender string, msg *[]byte, reply *wasmvmtypes.Reply, funds sdktypes.Coins, response *wasmvmtypes.Response, gasUsed uint64) {
+	// If checking TX (simulating, not actually executing), do not index.
+	if iw.ctx.IsCheckTx() {
+		return
+	}
+
+	encoder := json.NewEncoder(iw.file)
+
+	// Export event.
+	var msgBase64 string
+	if msg != nil {
+		msgBase64 = base64.StdEncoding.EncodeToString(*msg)
+	}
+	event := IndexerTxEvent{
+		Type:            "tx",
+		BlockHeight:     iw.ctx.BlockHeight(),
+		BlockTimeUnixMs: iw.ctx.BlockTime().UnixMilli(),
+		TxIndex:         iw.env.Transaction.Index,
+		MessageId:       iw.getMessageId(),
+		ContractAddress: contractAddress.String(),
+		CodeId:          codeID,
+		Action:          action,
+		Sender:          sender,
+		Msg:             msgBase64,
+		Reply:           reply,
+		Funds:           funds,
+		Response:        response,
+		GasUsed:         gasUsed,
+	}
+	encoder.Encode(event)
+
+	iw.ctx.Logger().Info("[INDEXER][wasm/tx] Exported event", "blockHeight", event.BlockHeight, "txIndex", event.TxIndex, "messageId", event.MessageId, "contractAddress", event.ContractAddress, "sender", event.Sender, "output", iw.output)
+}
+
+// Close file.
+func (iw *IndexerTxWriter) Close() {
+	iw.file.Close()
+}
diff --git a/x/wasm/keeper/keeper.go b/x/wasm/keeper/keeper.go
index 0f6e1d2..ed9f2ae 100644
--- a/x/wasm/keeper/keeper.go
+++ b/x/wasm/keeper/keeper.go
@@ -16,6 +16,7 @@ import (
 	wasmvm "github.com/CosmWasm/wasmvm"
 	wasmvmtypes "github.com/CosmWasm/wasmvm/types"
 	"github.com/cosmos/cosmos-sdk/codec"
+	"github.com/cosmos/cosmos-sdk/store/listenkv"
 	"github.com/cosmos/cosmos-sdk/store/prefix"
 	"github.com/cosmos/cosmos-sdk/telemetry"
 	sdk "github.com/cosmos/cosmos-sdk/types"
@@ -27,6 +28,8 @@ import (
 
 	"github.com/CosmWasm/wasmd/x/wasm/ioutils"
 	"github.com/CosmWasm/wasmd/x/wasm/types"
+
+	sdkstore "github.com/cosmos/cosmos-sdk/store/types"
 )
 
 // contractMemoryLimit is the memory limit of each contract execution (in MiB)
@@ -83,6 +86,13 @@ var defaultAcceptedAccountTypes = map[reflect.Type]struct{}{
 	reflect.TypeOf(&authtypes.BaseAccount{}): {},
 }
 
+// INDEXER.
+var CurrentIndexerStateListener *IndexerStateWriteListener
+var CurrentIndexerTxWriter *IndexerTxWriter
+var CurrentIndexerTxBlockHeight int64
+var CurrentIndexerTxIndex uint32
+var CurrentIndexerTxRootMessageIndex uint32
+
 // Keeper will have a reference to Wasmer with it's own data directory.
 type Keeper struct {
 	storeKey              sdk.StoreKey
@@ -102,6 +112,9 @@ type Keeper struct {
 	maxQueryStackSize    uint32
 	acceptedAccountTypes map[reflect.Type]struct{}
 	accountPruner        AccountPruner
+
+	// INDEXER.
+	indexerConfig IndexerConfig
 }
 
 // NewKeeper creates a new contract Keeper instance
@@ -134,6 +147,8 @@ func NewKeeper(
 		paramSpace = paramSpace.WithKeyTable(types.ParamKeyTable())
 	}
 
+	indexerConfig := LoadIndexerConfig(filepath.Join(homeDir, ".."))
+
 	keeper := &Keeper{
 		storeKey:             storeKey,
 		cdc:                  cdc,
@@ -149,6 +164,7 @@ func NewKeeper(
 		gasRegister:          NewDefaultWasmGasRegister(),
 		maxQueryStackSize:    types.DefaultMaxQueryStackSize,
 		acceptedAccountTypes: defaultAcceptedAccountTypes,
+		indexerConfig:        indexerConfig,
 	}
 	keeper.wasmVMQueryHandler = DefaultQueryPlugins(bankKeeper, stakingKeeper, distKeeper, channelKeeper, keeper)
 	for _, o := range opts {
@@ -159,6 +175,66 @@ func NewKeeper(
 	return *keeper
 }
 
+// INDEXER: Setup indexer listener and writer.
+func (k Keeper) setupIndexer(ctx *sdk.Context, env *wasmvmtypes.Env, prefixStore *prefix.Store, contractAddress sdk.AccAddress, codeID uint64) (sdkstore.KVStore, *IndexerStateWriteListener, *IndexerTxWriter) {
+	// If checking TX (simulating, not actually executing), do not attach indexer.
+	// Return prefixStore not wrapped with listenkv.
+	if ctx.IsCheckTx() {
+		return prefixStore, nil, nil
+	}
+
+	// Create state listener.
+	stateListener := NewIndexerStateWriteListener(
+		k.indexerConfig,
+		CurrentIndexerStateListener,
+		ctx,
+		// Contract info.
+		contractAddress,
+		codeID,
+	)
+
+	// If we fail to create a new listener, return prefixStore not wrapped with
+	// listenkv. This may happen if a config filter is not met.
+	if stateListener == nil {
+		return prefixStore, nil, nil
+	}
+
+	// Update CurrentIndexerListener.
+	CurrentIndexerStateListener = stateListener
+
+	// Create KV store that calls the listener when data is updated. Store key
+	// does not matter.
+	store := listenkv.NewStore(prefixStore, k.storeKey, []sdkstore.WriteListener{
+		stateListener,
+	})
+
+	// If on a new block height or transaction index, reset the root-level message
+	// index. The appropriate message index (the root-level or a parent's
+	// sub-message index) will be incremented automatically by the TX writer when
+	// it finishes.
+	if CurrentIndexerTxBlockHeight != ctx.BlockHeight() || env.Transaction.Index != CurrentIndexerTxIndex {
+		CurrentIndexerTxWriter = nil
+		CurrentIndexerTxRootMessageIndex = 0
+	}
+
+	// Update the current values of the block height and transaction index.
+	CurrentIndexerTxBlockHeight = ctx.BlockHeight()
+	CurrentIndexerTxIndex = env.Transaction.Index
+
+	// Create TX writer.
+	txWriter := NewIndexerTxWriter(
+		k.indexerConfig,
+		CurrentIndexerTxWriter,
+		ctx,
+		env,
+	)
+
+	// Update CurrentIndexerTxWriter.
+	CurrentIndexerTxWriter = txWriter
+
+	return store, stateListener, txWriter
+}
+
 func (k Keeper) getUploadAccessConfig(ctx sdk.Context) types.AccessConfig {
 	var a types.AccessConfig
 	k.paramSpace.Get(ctx, types.ParamStoreKeyUploadAccess, &a)
@@ -361,12 +437,21 @@ func (k Keeper) instantiate(
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
 	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, codeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 
 	// instantiate wasm contract
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Instantiate(codeInfo.CodeHash, env, info, initMsg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, nil, sdkerrors.Wrap(types.ErrInstantiateFailed, err.Error())
@@ -403,11 +488,19 @@ func (k Keeper) instantiate(
 		sdk.NewAttribute(types.AttributeKeyCodeID, strconv.FormatUint(codeID, 10)),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	txWriter.write(contractAddress, codeID, "instantiate", creator.String(), &initMsg, nil, deposit, res, gasUsed)
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return contractAddress, data, nil
 }
 
@@ -436,10 +529,19 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 	env := types.NewEnv(ctx, contractAddress)
 	info := types.NewInfo(caller, coins)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Execute(codeInfo.CodeHash, env, info, msg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -450,11 +552,19 @@ func (k Keeper) execute(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	txWriter.write(contractAddress, contractInfo.CodeID, "execute", caller.String(), &msg, nil, coins, res, gasUsed)
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -503,8 +613,18 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 
 	prefixStoreKey := types.GetContractStorePrefix(contractAddress)
 	prefixStore := prefix.NewStore(ctx.KVStore(k.storeKey), prefixStoreKey)
+
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, newCodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, &prefixStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, err := k.wasmVM.Migrate(newCodeInfo.CodeHash, env, msg, indexerStateStore, cosmwasmAPI, &querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if err != nil {
 		return nil, sdkerrors.Wrap(types.ErrMigrationFailed, err.Error())
@@ -523,11 +643,19 @@ func (k Keeper) migrate(ctx sdk.Context, contractAddress sdk.AccAddress, caller
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	txWriter.write(contractAddress, newCodeID, "migrate", caller.String(), &msg, nil, sdk.NewCoins(), res, gasUsed)
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -546,10 +674,19 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
-	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Sudo(codeInfo.CodeHash, env, msg, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -560,11 +697,19 @@ func (k Keeper) Sudo(ctx sdk.Context, contractAddress sdk.AccAddress, msg []byte
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	txWriter.write(contractAddress, contractInfo.CodeID, "sudo", "sudo", &msg, nil, sdk.NewCoins(), res, gasUsed)
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
@@ -581,11 +726,20 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 
 	env := types.NewEnv(ctx, contractAddress)
 
+	// INDEXER: Setup indexer.
+	indexerStateStore, stateListener, txWriter := k.setupIndexer(&ctx, &env, &prefixStore, contractAddress, contractInfo.CodeID)
+	if stateListener != nil {
+		defer stateListener.finish()
+	}
+	if txWriter != nil {
+		defer txWriter.finish()
+	}
+
 	// prepare querier
 	querier := k.newQueryHandler(ctx, contractAddress)
 	gas := k.runtimeGasForContract(ctx)
 
-	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, prefixStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
+	res, gasUsed, execErr := k.wasmVM.Reply(codeInfo.CodeHash, env, reply, indexerStateStore, cosmwasmAPI, querier, k.gasMeter(ctx), gas, costJSONDeserialization)
 	k.consumeRuntimeGas(ctx, gasUsed)
 	if execErr != nil {
 		return nil, sdkerrors.Wrap(types.ErrExecuteFailed, execErr.Error())
@@ -596,11 +750,19 @@ func (k Keeper) reply(ctx sdk.Context, contractAddress sdk.AccAddress, reply was
 		sdk.NewAttribute(types.AttributeKeyContractAddr, contractAddress.String()),
 	))
 
+	// INDEXER: Write tx before sub-messages are dispatched.
+	txWriter.write(contractAddress, contractInfo.CodeID, "reply", "reply", nil, &reply, sdk.NewCoins(), res, gasUsed)
+
 	data, err := k.handleContractResponse(ctx, contractAddress, contractInfo.IBCPortID, res.Messages, res.Attributes, res.Data, res.Events)
 	if err != nil {
 		return nil, sdkerrors.Wrap(err, "dispatch")
 	}
 
+	// INDEXER: On success, commit, after sub-messages are dispatched.
+	if stateListener != nil {
+		stateListener.commit()
+	}
+
 	return data, nil
 }
 
diff --git a/x/wasm/keeper/test_common.go b/x/wasm/keeper/test_common.go
index 8ee5261..a118a69 100644
--- a/x/wasm/keeper/test_common.go
+++ b/x/wasm/keeper/test_common.go
@@ -304,6 +304,7 @@ func createTestInput(
 		accountKeeper,
 		bankKeeper,
 		subspace(stakingtypes.ModuleName),
+		"",
 	)
 	stakingKeeper.SetParams(ctx, TestingStakeParams)
 
